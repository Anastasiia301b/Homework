


// console.log ("number" + 3 + 3) 
// 		// Тут відбудеться конкатинація операндів ("number" + 3), а потім ще конкатинація 3 
             



// console.log ("qwerty" && 5); 
//     		// Оператор  &&  поверне останню змінну, бо наші операнди є "вірними".


// console.log(+'40' + +'2' + "hillel");
// 			// 1. Два унарних плюса для двох стрінг призведе їх до чисел, 
// 			// 2. Потім рахується сума перших двох чисел і їх наступна конкатинація з "hillel"


// console.log ('10' - 5 === 6);
// 			// 1. "10" призведеться до числа, 
// 			// 2. (10 -5)=5 
// 			// 3. 5 не дорівнює 6, тому false

// console.log(true + false)
// 			// Булінові оператори призведуться до чисел: 1+0=1


// console.log('4px'-3)
// 			// Перша змінна не може бути призведена до числа, то відповідь Nan, котлети з мухами не мішаємо


// console.log('4' - 3)
// 			// А тут стрінга призведеться до числа і буде обчислена як звичайний математичний приклад




//  console.log('6' + 3 ** 0);
// 		 // 1. Возводимо 3 в 0 ступіні=1, операція за приоритетом
// 		 // 2. Конкатинація  "6"+1="61"



// console.log (12/'6')
// 		Призведення стринги до числа, обчислить як приклад, але цікаво що тип даних NaN


//console.log ('10' + (5 === 6));
// 			1. Починаємо з виразу в дужках, отримуємо FALSE
// 			2.Складання 2 різних типів даних призведе до їх конкатинації: 10false


// console.log (null == '')
// 			1.Тут логіка ломається у мене, якщо Null і пуста строка завжди призводять до False,то воно мало б бути true. 
// 			Aле тут не відбулось автопризведення типів, то є false, адже типи даних різні.


// console.log (3 ** (9 / 3));
// 			1.Рахуємо вираз в дужках
// 			2.Возводимо 3 в 3 ступінь, буде 27 



// console.log (!!'false' == !!'true')
// 	 			1. Тут мають інвертуватися значенння:
// 	 				але я не зрозуміла, чому !'false'=false, 
// 			     	a !!'false'=true,
// тоді як 
// 			    	!'true' поверне falsе, 
//                  а !!'true'=true
// 				 2. тому кінцевий вираз true==true, буде true



// console.log (0 || '0' && 1)
// 		
// 							1. 0 || '0' (перший 0 , буде false, '0' -повертається) 
//                         2. '0' && 1 (дві операнди є true, то вернеться остання)



// console.log((+null == false) < 1)
// 							1. +null=0 ; 
// 							2. (0 ==false) це true, бо оператор нестрогої рівності автоматично призвів операнду false  до числа,
// 							3. оскільки true приведеться до  1, то вираз 1<1  видасть нам FALSE


// console.log (false && true || true)
// 							1.false && true, повернеться false
// 							2. false || true , віддасть true

// console.log (false && (false || true))
// 							1. (false || true), буде true
// 							2. false && true, віддасть false


// console.log ((+null == false) < 1 ** 5);

// 							1. Обчислюємо вираз в дужках, буде true (або 1)
// 			 				2. Возводимо 1 в п'яту ступінь, отримуємо 1
// 							3. 1 < 1 буде False